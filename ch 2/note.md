# 地址标准
涉及数组元素，如：`lw  $s1, 20($s2)`，其中20对应**字节地址**，若`$s2`中基地址对应的数组为`int`类型数组，则表示`a[5]`。

涉及跳转指令，如：`beq  $s1, $s2, 25`，其中25表示从`PC+4`开始的`offset`，是**字地址**，在内存中的字节地址实际上为`PC+4+100`。

# 32个寄存器
| 寄存器号  | 符号名  | 用途                                                                    |
|-----------|---------|-------------------------------------------------------------------------|
| **0**     | 始终为0 | 看起来象浪费,其实很有用                                                 |
| 1         | at      | 保留给汇编器使用                                                        |
| 2-3       | v0,v1   | 函数返回值                                                              |
| 4-7       | a0-a3   | 前头几个函数参数                                                        |
| **8-15**  | t0-t7   | 临时寄存器,子过程可以不保存就使用                                       |
| 24-25     | t8,t9   | 同上                                                                    |
| **16-23** | s0-s7   | 寄存器变量,子过程要使用它必须先保存然后在退出前恢复以保留调用者需要的值 |
| 26,27     | k0,k1   | 保留给异常处理函数使用                                                  |
| 28        | gp      | global pointer;用于方便存取全局或者静态变量                             |
| 29        | sp      | stack pointer                                                           |
| 30        | s8/fp   | 第9个寄存器变量;子过程可以用它做frame pointer                           |
| **31**    | ra      | 返回地址                                                                |

# 立即数
因为`add`命令操作常数涉及取数操作，速度很慢，所以设计一个专门对常数的算术指令`addi`，因为常数可以是负数，因此没有减法的立即数操作。特别的，`0`只能用`$zero`寄存器表示，MIPS中无`mov`指令，因为这与`add $s0,$s1,$zero`等效。

# R型和I型指令
`rs/rt/rs`都是五位是因为**只有32个寄存器**；`shamt`根据机器类型，32位机则为五位，因为最多移位31位；

I型指令中，`rt`寄存器**可能代表源寄存器也可能是目的寄存器**，如在取字指令中为目的寄存器（因为只需要一个源寄存器，必然是`rs`，所以`rt`为目的寄存器）

**逻辑移位操作都是R型**，因为需要用到`shamt`位。