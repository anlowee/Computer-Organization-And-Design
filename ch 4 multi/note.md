# 多周期的好处
+ 时钟频率高，或者说时钟周期小，因为很慢的操作被分成了几个部分，则时钟周期从最长操作的时间变成最长部分的时间。
+ 方便控制。
+ 单周期中一个组件一个周期内只能干一件事，但多周期一个组件可以在不同周期内干不同事，所以多周期没有很多重复元件。比如PC+4在单周期中需要单独的Add元件，但在多周期中可以只用一个ALU。
+ 数据通路简单

# 多周期的缺点
+ 控制器设计复杂
+ 性能还是不能满足需要

# 多周期不同于单周期之处
+ 多周期需要更多寄存器来保存中间状态。
+ PC不是每次+4了（即不是每次都有写指令），当且仅当取完指令后PC+4。
+ 多周期需要拆分指令，关键需要使得每个部分消耗时间大致相同。
+ 单周期中的控制信号在指令译码时全部生成；多周期中控制信号根据当前所处第几个周期产生不同的控制信号。
+ 多周期不能像单周期那样用真值表表示状态，多周期处理器用状态机表示状态。

# 分步骤
其中所有的`=`都表示写操作，一个元件一个周期只能写一次。每条指令需要3~5步完成，lw最慢，需要5步。
## IF
+ IR = Memory[PC]
+ PC = PC + 4，此处写回PC+4的好处是如果是转移指令加下来可以直接用（因为所有的转移指令都是基于PC+4的，不然就是branch指令直接跳到一个指定的地址）

## ID
+ A = Reg[IR[25-21]]
+ B = Reg[IR[20-16]]
+ ALUOut = PC + (sign-extend(IR[15-0]) << 2)

该步骤中做的事：
+ 译码(decoding)，IR[25-21]这些都是译码
+ 读寄存器（读A，B）
+ 计算转移地址（用ALU）

## EXE（不同指令不一样）
### lw & sw
+ ALUOut = A + sign-extend(IR[15-0])

### R-type
+ ALUOut = A op B

### Branch（到这一步结束）
+ if (A == B) PC = ALUOut

### Jump（到这一步结束）
+ PC = PC[31-28] || (IR[25-0] << 2)

## Mem
### lw
+ MDR = Memory[ALUOut]

### sw（到这一步结束）
+ Memory[ALUOut] = B

## WB
### R-type（到这一步结束）
+ Reg[IR[15-11]] = ALUOut

### lw（到这一步结束）
+ Reg[IR[20-16]] = MDR

# 微程序
为了简化状态机，给每个状态创建一个指令。指令形式：control码:下一个状态码（微指令：microinstruciton）

每次只需要对微指令译码即可，例如beq可由3条微指令构成（一条微程序），所有的微程序放在指定存储器中，是一个只读存储器。

其中control码包含控制信号，但若包含所有信号，则微指令可能会很长，注意到有些信号不可能同时出现，则可指令分为不同集合，则只须将指令对应的集合中的信号表示出来即可。

控制存储器（CM）根据微程序计数器的结果找到对应的微指令译码。

组合逻辑控制器优点：非常快，但难设计（可用来设计简单指令）
微程序控制器：设计简单，但性能低（用来设计复杂指令）
